// !!! This is a file automatically generated by hipify!!!
#include <ATen/hip/detail/LazyNVRTC.h>

#include <ATen/hip/nvrtc_stub/ATenNVRTC.h>
#include <ATen/DynamicLibrary.h>
#include <stdexcept>
#include <mutex>  // for std::call_once

namespace at {
namespace cuda {
namespace detail {
namespace _stubs {

at::DynamicLibrary& getCUDALibrary() {
#if defined(_WIN32)
  static at::DynamicLibrary lib("nvcuda.dll");
#else
  static at::DynamicLibrary lib("libcuda.so.1");
#endif
  return lib;
}

static std::string getLibVersion() {
  // [NVRTC versioning]
  // Quote of https://docs.nvidia.com/cuda/nvrtc/index.html Section 8.1. NVRTC library versioning
  //
  // In the following, MAJOR and MINOR denote the major and minor versions of the CUDA Toolkit.
  // e.g. for CUDA 11.2, MAJOR is "11" and MINOR is "2".
  //
  // Linux:
  //   - In CUDA toolkits prior to CUDA 11.3, the soname was set to "MAJOR.MINOR".
  //   - In CUDA 11.3 and later 11.x toolkits, the soname field is set to "11.2".
  //   - In CUDA toolkits with major version > 11 (e.g. CUDA 12.x), the soname field is set to "MAJOR".
  //
  // Windows:
  //   - In CUDA toolkits prior to cuda 11.3, the DLL name was of the form "nvrtc64_XY_0.dll", where X = MAJOR, Y = MINOR.
  //   - In CUDA 11.3 and later 11.x toolkits, the DLL name is "nvrtc64_112_0.dll".
  //   - In CUDA toolkits with major version > 11 (e.g. CUDA 12.x), the DLL name is of the form "nvrtc64_X0_0.dll" where X = MAJOR.
  //
  // Consider a CUDA toolkit with major version > 11. The NVRTC library in this CUDA toolkit will have the same soname (Linux)
  // or DLL name (Windows) as an NVRTC library in a previous minor version of the same CUDA toolkit. Similarly, the NVRTC
  // library in CUDA 11.3 and later 11.x releases will have the same soname (Linux) or DLL name (Windows) as the NVRTC library in CUDA 11.2.
  constexpr auto major = HIP_VERSION / 1000;
  constexpr auto minor = ( HIP_VERSION / 10 ) % 10;
#if defined(_WIN32)
  if (major < 11 || (major == 11 && minor < 3)) {
    return std::to_string(major) + std::to_string(minor);
  } else if (major == 11) {
    return "112";
  } else {
    return std::to_string(major) + "0";
  }
#else
  if (major < 11 || (major == 11 && minor < 3)) {
    return std::to_string(major) + "." + std::to_string(minor);
  } else if (major == 11) {
    return "11.2";
  } else {
    return std::to_string(major);
  }
#endif
}

static std::string getLibName() {
#if defined(_WIN32)
  return std::string("nvrtc64_") + getLibVersion() + "_0.dll";
#else
  return std::string("libnvrtc.so.") + getLibVersion();
#endif
}

static std::string getAltLibName() {
#if !defined(_WIN32) && defined(NVRTC_SHORTHASH)
  return std::string("libnvrtc-") + C10_STRINGIZE(NVRTC_SHORTHASH) + ".so." + getLibVersion();
#else
  return {};
#endif
}

at::DynamicLibrary& getNVRTCLibrary() {
  static std::string libname = getLibName();
  static std::string alt_libname = getAltLibName();
  static at::DynamicLibrary lib(libname.c_str(), alt_libname.empty() ? nullptr : alt_libname.c_str());
  return lib;
}

#define _STUB_1(LIB, NAME, RETTYPE, ARG1)                                            \
RETTYPE NAME(ARG1 a1) {                                                              \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1);                                                                     \
}

#define _STUB_2(LIB, NAME, RETTYPE, ARG1, ARG2)                                      \
RETTYPE NAME(ARG1 a1, ARG2 a2) {                                                     \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2);                                                                 \
}

#define _STUB_3(LIB, NAME, RETTYPE, ARG1, ARG2, ARG3)                                \
RETTYPE NAME(ARG1 a1, ARG2 a2, ARG3 a3) {                                            \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2, a3);                                                             \
}

#define _STUB_4(LIB, NAME, RETTYPE, ARG1, ARG2, ARG3, ARG4)                          \
RETTYPE NAME(ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4) {                                   \
  auto fn = reinterpret_cast<decltype(&NAME)>(get## LIB ## Library().sym(__func__)); \
  if (!fn)                                                                           \
    throw std::runtime_error("Can't get " C10_STRINGIZE(NAME) );                     \
  lazyNVRTC.NAME = fn;                                                               \
  return fn(a1, a2, a3, a4);                                                         \
}

#define CUDA_STUB1(NAME, A1) _STUB_1(CUDA, NAME, hipError_t CUDAAPI, A1)
#define CUDA_STUB2(NAME, A1, A2) _STUB_2(CUDA, NAME, hipError_t CUDAAPI, A1, A2)
#define CUDA_STUB3(NAME, A1, A2, A3) _STUB_3(CUDA, NAME, hipError_t CUDAAPI, A1, A2, A3)
#define CUDA_STUB4(NAME, A1, A2, A3, A4) _STUB_4(CUDA, NAME, hipError_t CUDAAPI, A1, A2, A3, A4)

#define NVRTC_STUB1(NAME, A1) _STUB_1(NVRTC, NAME, hiprtcResult, A1)
#define NVRTC_STUB2(NAME, A1, A2) _STUB_2(NVRTC, NAME, hiprtcResult, A1, A2)
#define NVRTC_STUB3(NAME, A1, A2, A3) _STUB_3(NVRTC, NAME, hiprtcResult, A1, A2, A3)

NVRTC_STUB2(hiprtcVersion, int*, int*);
NVRTC_STUB2(hiprtcAddNameExpression, hiprtcProgram, const char * const);

hiprtcResult hiprtcCreateProgram(hiprtcProgram *prog,
                               const char *src,
                               const char *name,
                               int numHeaders,
                               const char * const *headers,
                               const char * const *includeNames) {
  auto fn = reinterpret_cast<decltype(&hiprtcCreateProgram)>(getNVRTCLibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hiprtcCreateProgram");
  lazyNVRTC.hiprtcCreateProgram = fn;
  return fn(prog, src, name, numHeaders, headers, includeNames);
}

NVRTC_STUB1(hiprtcDestroyProgram, hiprtcProgram *);
NVRTC_STUB2(hiprtcGetCodeSize, hiprtcProgram, size_t *);
NVRTC_STUB2(hiprtcGetCode, hiprtcProgram, char *);
#if HIP_VERSION >= 11010
NVRTC_STUB2(nvrtcGetCUBINSize, hiprtcProgram, size_t *);
NVRTC_STUB2(nvrtcGetCUBIN, hiprtcProgram, char *);
#endif
NVRTC_STUB3(hiprtcCompileProgram, hiprtcProgram, int, const char * const *);
_STUB_1(NVRTC, hiprtcGetErrorString, const char *, hiprtcResult);
NVRTC_STUB2(hiprtcGetProgramLogSize,hiprtcProgram, size_t*);
NVRTC_STUB2(hiprtcGetProgramLog, hiprtcProgram, char *);
NVRTC_STUB3(hiprtcGetLoweredName, hiprtcProgram, const char *, const char **);

CUDA_STUB2(hipModuleLoadData, hipModule_t *, const void *);
CUDA_STUB3(hipModuleGetFunction, hipFunction_t *, hipModule_t, const char *);
CUDA_STUB4(hipModuleOccupancyMaxActiveBlocksPerMultiprocessor, int *, hipFunction_t, int, size_t);
CUDA_STUB2(hipGetErrorString___, hipError_t, const char **);
CUDA_STUB1(hipCtxGetCurrent, hipCtx_t *);
CUDA_STUB1(hipModuleUnload, hipModule_t);
CUDA_STUB3(hipDevicePrimaryCtxGetState, hipDevice_t, unsigned int *, int *);
CUDA_STUB4(hipLinkCreate, unsigned int, hipJitOption *, void **, CUlinkState *);
CUDA_STUB3(hipLinkComplete, CUlinkState, void **, size_t *);

// Irregularly shaped functions
hipError_t CUDAAPI hipModuleLaunchKernel(hipFunction_t f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                hipStream_t hStream,
                                void **kernelParams,
                                void **extra) {
  auto fn = reinterpret_cast<decltype(&hipModuleLaunchKernel)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipModuleLaunchKernel");
  lazyNVRTC.hipModuleLaunchKernel = fn;
  return fn(f,
            gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ,
            sharedMemBytes, hStream, kernelParams, extra);
}

hipError_t CUDAAPI hipModuleLoadDataEx(hipModule_t *module,
                                    const void *image,
                                    unsigned int numOptions,
                                    hipJitOption *options,
                                    void **optionValues) {
  auto fn = reinterpret_cast<decltype(&hipModuleLoadDataEx)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipModuleLoadDataEx");
  lazyNVRTC.hipModuleLoadDataEx = fn;
  return fn(module, image, numOptions, options, optionValues);
}

hipError_t CUDAAPI
hipLinkAddData(CUlinkState state,
              hipJitInputType type,
              void *data,
              size_t size,
              const char *name,
              unsigned int numOptions,
              hipJitOption *options,
              void **optionValues) {
  auto fn = reinterpret_cast<decltype(&hipLinkAddData)>(getCUDALibrary().sym(__func__));
  if (!fn)
    throw std::runtime_error("Can't get hipLinkAddData");
  lazyNVRTC.hipLinkAddData = fn;
  return fn(state, type, data, size, name, numOptions, options, optionValues);
}

} // namespace _stubs

NVRTC lazyNVRTC = {
#define _REFERENCE_MEMBER(name) _stubs::name,
  AT_FORALL_NVRTC(_REFERENCE_MEMBER)
#undef _REFERENCE_MEMBER
};
} // namespace detail
} // namespace cuda
} // namespace at
